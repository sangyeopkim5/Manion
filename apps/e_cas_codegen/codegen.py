"""LLM powered Manim + CAS generation wired for the deterministic pipeline."""

from __future__ import annotations

import base64
import json
import os
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

import tomllib
from dotenv import load_dotenv
from openai import OpenAI

BASE_DIR = Path(__file__).resolve().parent
CONFIG_DIR = BASE_DIR.parent.parent / "configs"
SYSTEM_PROMPT_PATH = BASE_DIR / "system_prompt.txt"

load_dotenv()


@dataclass
class CodegenResult:
    code_path: Path
    manim_path: Path
    jobs_path: Path
    jobs: List[Dict[str, Any]]
    manim_code: str
    status: str

    def as_dict(self) -> Dict[str, Any]:
        return {
            "code_path": str(self.code_path),
            "manim_path": str(self.manim_path),
            "jobs_path": str(self.jobs_path),
            "jobs": self.jobs,
            "manim_code": self.manim_code,
            "status": self.status,
        }


def load_system_prompt() -> str:
    if SYSTEM_PROMPT_PATH.exists():
        return SYSTEM_PROMPT_PATH.read_text(encoding="utf-8")
    return "You are a Manim+CAS code generator."


def _load_openai_config() -> Dict[str, Any]:
    cfg_path = CONFIG_DIR / "openai.toml"
    if not cfg_path.exists():
        return {"model": "gpt-4o-mini", "temperature": 0.0}
    with cfg_path.open("rb") as fh:
        cfg = tomllib.load(fh)
    section = cfg.get("cas_codegen") or cfg.get("default", {})
    default = cfg.get("default", {})
    model = section.get("model") or default.get("model") or "gpt-4o-mini"
    temperature = section.get("temperature", 0.0)
    return {"model": model, "temperature": float(temperature)}


def _encode_image(path: Path) -> Optional[Dict[str, str]]:
    """이미지를 base64로 인코딩하여 OpenAI API에 전송할 수 있는 형태로 변환"""
    if not path.exists():
        return None
    mime = "image/jpeg"
    ext = path.suffix.lower()
    if ext == ".png":
        mime = "image/png"
    try:
        data = base64.b64encode(path.read_bytes()).decode("utf-8")
    except Exception:
        return None
    return {"type": "image_url", "image_url": {"url": f"data:{mime};base64,{data}"}}


def _find_crop_images(problem_dir: Path) -> List[Path]:
    """crop된 이미지 파일들을 찾아서 반환"""
    crop_images = []
    for pattern in ["*__pic_i*.jpg", "*__pic_i*.png", "*__pic_i*.jpeg"]:
        crop_images.extend(sorted(problem_dir.glob(pattern)))
    return crop_images


def _select_problem_image(problem_dir: Path) -> Optional[Path]:
    """문제 이미지 선택"""
    for name in ["problem.jpg", "problem_input.jpg", "problem_input.png"]:
        candidate = problem_dir / name
        if candidate.exists():
            return candidate
    return None


def _has_pictures_in_ocr(problem_dir: Path) -> bool:
    """OCR 결과에서 Picture가 있는지 확인"""
    ocr_path = problem_dir / "problem.json"
    if not ocr_path.exists():
        return False
    
    try:
        with ocr_path.open("r", encoding="utf-8") as f:
            ocr_data = json.load(f)
        
        if isinstance(ocr_data, list):
            return any(item.get("category") == "Picture" for item in ocr_data)
        return False
    except Exception:
        return False


def extract_jobs_and_code(content: str) -> tuple[List[Dict[str, Any]], str]:
    """---CAS-JOBS--- 섹션을 추출하여 CAS 작업과 Manim 코드를 분리"""
    # ---CAS-JOBS--- 섹션 찾기
    cas_section_pattern = r"---CAS-JOBS---\s*\n(.*?)(?=\n---|\Z)"
    cas_match = re.search(cas_section_pattern, content, re.DOTALL)
    
    if cas_match:
        cas_text = cas_match.group(1).strip()
        # 나머지 부분이 Manim 코드
        manim_code = content[:cas_match.start()].strip()
        
        try:
            cas_jobs = json.loads(cas_text)
            if not isinstance(cas_jobs, list):
                cas_jobs = []
        except json.JSONDecodeError:
            cas_jobs = []
    else:
        # CAS 섹션이 없으면 전체를 Manim 코드로 간주
        manim_code = content.strip()
        cas_jobs = []
    
    return cas_jobs, manim_code


def _placeholder_output(problem_dir: Path, reason: str) -> CodegenResult:
    """플레이스홀더 출력 생성"""
    code_path = problem_dir / "codegen_output.py"
    manim_path = problem_dir / "manim_draft.py"
    jobs_path = problem_dir / "cas_jobs.json"

    placeholder = (
        "# Placeholder generated by cas_codegen\n"
        f"# Reason: {reason}\n\n"
        "from manim import *\n\n\n"
        "class ProblemScene(Scene):\n"
        "    def construct(self):\n"
        "        self.add(Text('Fill in Manim code based on problem').scale(0.6))\n"
    )

    code_path.write_text(placeholder + "\n---CAS-JOBS---\n[]\n", encoding="utf-8")
    manim_path.write_text(placeholder, encoding="utf-8")
    jobs_path.write_text("[]\n", encoding="utf-8")

    return CodegenResult(
        code_path=code_path,
        manim_path=manim_path,
        jobs_path=jobs_path,
        jobs=[],
        manim_code=placeholder,
        status="placeholder",
    )


def run_cas_codegen_for_multiple_results(
    problem_dir: str | Path,
    *,
    ocr_json_path: str | Path | None = None,
    image_path: Optional[str] = None,
    force: bool = False,
    model: Optional[str] = None,
    temperature: Optional[float] = None,
    client: Optional[OpenAI] = None,
) -> Dict[str, Any]:
    """항상 Manim 코드와 CAS 작업을 생성 (D 결과 유무에 관계없이)"""
    
    problem_dir_path = Path(problem_dir).expanduser().resolve()
    ocr_json_path = Path(ocr_json_path or (problem_dir_path / "problem.json"))
    image_candidate = Path(image_path).expanduser() if image_path else _select_problem_image(problem_dir_path)
    
    if not ocr_json_path.exists():
        raise FileNotFoundError(f"problem.json not found at {ocr_json_path}")
    
    if not image_candidate or not image_candidate.exists():
        raise FileNotFoundError(f"image file not found - required for cas_codegen")

    # 모든 geo_result_*.json 파일 찾기 (D_geo_compute 디렉토리에서)
    import glob
    # A_OCR 디렉토리의 부모 디렉토리에서 D_geo_compute 디렉토리 찾기
    parent_dir = problem_dir_path.parent
    d_geo_dir = parent_dir / "stage_d_geo_compute"
    
    if d_geo_dir.exists():
        result_files = sorted(glob.glob(str(d_geo_dir / "geo_result_*.json")))
        print(f"[e_cas_codegen] Found {len(result_files)} geo result files in {d_geo_dir}")
    else:
        result_files = []
        print(f"[e_cas_codegen] No D_geo_compute directory found at {d_geo_dir}")
    
    # 모든 결과 파일 로드
    geo_results = []
    for result_file in result_files:
        try:
            with open(result_file, "r", encoding="utf-8") as f:
                result_data = json.load(f)
            if result_data.get("status") == "solved":
                geo_results.append(result_data)
                print(f"[e_cas_codegen] Loaded {Path(result_file).name}")
            else:
                print(f"[e_cas_codegen] Skipped {Path(result_file).name} (status: {result_data.get('status')})")
        except Exception as e:
            print(f"[e_cas_codegen] Failed to load {result_file}: {e}")
    
    print(f"[e_cas_codegen] Loaded {len(geo_results)} valid geo results")
    
    code_path = problem_dir_path / "codegen_output.py"
    manim_path = problem_dir_path / "manim_draft.py"
    jobs_path = problem_dir_path / "cas_jobs.json"

    if not force and code_path.exists() and manim_path.exists() and jobs_path.exists():
        jobs = json.loads(jobs_path.read_text(encoding="utf-8"))
        manim_code = manim_path.read_text(encoding="utf-8")
        return CodegenResult(code_path, manim_path, jobs_path, jobs, manim_code, "reused").as_dict()

    cfg = _load_openai_config()
    model_name = model or cfg.get("model", "gpt-4o-mini")
    temp = temperature if temperature is not None else cfg.get("temperature", 0.0)

    if client is None:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            return _placeholder_output(problem_dir_path, "OPENAI_API_KEY not configured").as_dict()
        client = OpenAI(api_key=api_key)

    # OCR 데이터 로드
    ocr_data = json.loads(ocr_json_path.read_text(encoding="utf-8"))

    # 이미지 수집 (순서 보장)
    images: List[Path] = []
    if image_candidate:
        images.append(image_candidate)
    
    # crop 이미지들을 A_OCR 디렉토리에서 찾기
    crop_images = _find_crop_images(problem_dir_path)
    # 이미지 번호 순으로 정렬 (__pic_i0, __pic_i1, __pic_i2, ...)
    crop_images.sort(key=lambda x: int(x.stem.split("__pic_i")[1]) if "__pic_i" in x.stem else 0)
    images.extend(crop_images)
    
    print(f"[e_cas_codegen] Image order: {[img.name for img in images]}")
    print(f"[e_cas_codegen] Geo results order: {[result.get('image_index', i) for i, result in enumerate(geo_results)]}")

    # 사용자 메시지 구성 - D 결과 유무에 따른 분기
    if geo_results:
        # D 결과가 있는 경우: OCR JSON + 문제 전체 OCR 사진 + system_prompt + 개별 crop 이미지 + 매칭된 D 결과
        user_sections = [
            "문제의 OCR JSON과 여러 개의 해결된 기하학적 결과들을 참고하여 통합된 Manim 코드와 ---CAS-JOBS--- JSON 배열을 생성하세요.",
            f"총 {len(geo_results)}개의 기하학적 결과가 있습니다.",
            "[OCR JSON]\n" + json.dumps(ocr_data, ensure_ascii=False, indent=2),
        ]
        
        # 각 기하학적 결과를 순서대로 추가 (이미지와 JSON 결과 번호 매칭)
        for i, geo_result in enumerate(geo_results):
            image_index = geo_result.get("image_index", i)
            user_sections.extend([
                f"[Geometry Result {i + 1} - Image {image_index}]\n" + json.dumps(geo_result, ensure_ascii=False, indent=2),
            ])
        
        user_sections.extend([
            "위의 모든 기하학적 결과들을 하나의 통합된 Manim Scene으로 구성하세요. 각 결과는 해당하는 크롭된 이미지와 매칭되며, 별도의 도형으로 그려지되 전체적으로 조화롭게 배치하세요.",
            "이미지 번호와 JSON 결과 번호가 일치하므로, 각 Geometry Result는 해당 번호의 크롭된 이미지와 매칭됩니다."
        ])
    else:
        # D 결과가 없는 경우: OCR JSON + 문제 전체 OCR 사진 + system_prompt
        user_sections = [
            "문제의 OCR JSON과 이미지를 참고하여 Manim 코드와 ---CAS-JOBS--- JSON 배열을 생성하세요.",
            "[OCR JSON]\n" + json.dumps(ocr_data, ensure_ascii=False, indent=2),
        ]

    user_parts: List[Dict[str, Any]] = [{"type": "text", "text": "\n\n".join(user_sections)}]
    user_parts.extend(_gather_image_parts(images))

    messages = [
        {"role": "system", "content": load_system_prompt()},
        {"role": "user", "content": user_parts},
    ]

    try:
        response = client.chat.completions.create(
            model=model_name,
            temperature=temp,
            messages=messages,
        )
    except Exception as e:
        return _placeholder_output(problem_dir_path, f"OpenAI API error: {e}").as_dict()

    content = response.choices[0].message.content or ""
    
    # CAS 작업과 Manim 코드 분리
    cas_jobs, manim_code = extract_jobs_and_code(content)
    
    # 파일 저장
    code_path.write_text(content, encoding="utf-8")
    manim_path.write_text(manim_code, encoding="utf-8")
    jobs_path.write_text(json.dumps(cas_jobs, ensure_ascii=False, indent=2), encoding="utf-8")

    return CodegenResult(
        code_path=code_path,
        manim_path=manim_path,
        jobs_path=jobs_path,
        jobs=cas_jobs,
        manim_code=manim_code,
        status="generated",
    ).as_dict()

def run_cas_codegen(
    problem_dir: str | Path,
    *,
    spec_path: str | Path | None = None,
    ocr_json_path: str | Path | None = None,
    image_path: Optional[str] = None,
    force: bool = False,
    model: Optional[str] = None,
    temperature: Optional[float] = None,
    client: Optional[OpenAI] = None,
) -> Dict[str, Any]:
    """Generate Manim code and CAS jobs for the solved spec."""

    problem_dir_path = Path(problem_dir).expanduser().resolve()
    spec_path = Path(spec_path or (problem_dir_path / "spec.json"))
    ocr_json_path = Path(ocr_json_path or (problem_dir_path / "problem.json"))
    image_candidate = Path(image_path).expanduser() if image_path else _select_problem_image(problem_dir_path)
    if image_candidate and not image_candidate.exists():
        image_candidate = _select_problem_image(problem_dir_path)

    if not ocr_json_path.exists():
        raise FileNotFoundError(f"problem.json not found at {ocr_json_path}")
    
    # 이미지는 필수
    if not image_candidate or not image_candidate.exists():
        raise FileNotFoundError(f"image file not found - required for cas_codegen")

    # spec.json은 선택적 (그래프인 경우 없을 수 있음)
    spec = None
    if spec_path.exists():
        spec = json.loads(spec_path.read_text(encoding="utf-8"))
        if spec.get("status") != "solved":
            spec = None  # 해결되지 않은 spec은 무시

    ocr_data = json.loads(ocr_json_path.read_text(encoding="utf-8"))

    code_path = problem_dir_path / "codegen_output.py"
    manim_path = problem_dir_path / "manim_draft.py"
    jobs_path = problem_dir_path / "cas_jobs.json"

    if not force and code_path.exists() and manim_path.exists() and jobs_path.exists():
        jobs = json.loads(jobs_path.read_text(encoding="utf-8"))
        manim_code = manim_path.read_text(encoding="utf-8")
        return CodegenResult(code_path, manim_path, jobs_path, jobs, manim_code, "reused").as_dict()

    cfg = _load_openai_config()
    model_name = model or cfg.get("model", "gpt-4o-mini")
    temp = temperature if temperature is not None else cfg.get("temperature", 0.0)

    if client is None:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            return _placeholder_output(problem_dir_path, "OPENAI_API_KEY not configured").as_dict()
        client = OpenAI(api_key=api_key)

    # 이미지 수집
    images: List[Path] = []
    if image_candidate:
        images.append(image_candidate)
    
    # crop 이미지들 추가 (Picture가 있는 경우)
    if _has_pictures_in_ocr(problem_dir_path):
        crop_images = _find_crop_images(problem_dir_path)
        images.extend(crop_images)

    # 사용자 메시지 구성
    user_sections = [
        "문제의 OCR JSON을 참고하여 Manim 코드와 ---CAS-JOBS--- JSON 배열을 생성하세요.",
    ]
    
    if spec:
        user_sections.extend([
            "해결된 spec.json이 있으므로, spec.json에 기록된 좌표와 구조를 그대로 사용하여 도형을 구성하고, 추가 좌표를 임의로 만들지 마세요.",
            "[OCR JSON]\n" + json.dumps(ocr_data, ensure_ascii=False, indent=2),
            "[Solved Spec]\n" + json.dumps(spec, ensure_ascii=False, indent=2),
        ])
    else:
        user_sections.extend([
            "spec.json이 없으므로, OCR JSON과 이미지를 참고하여 문제를 해결하세요.",
            "[OCR JSON]\n" + json.dumps(ocr_data, ensure_ascii=False, indent=2),
        ])

    user_parts: List[Dict[str, Any]] = [{"type": "text", "text": "\n\n".join(user_sections)}]
    user_parts.extend(_gather_image_parts(images))

    response = client.chat.completions.create(
        model=model_name,
        messages=[
            {"role": "system", "content": load_system_prompt()},
            {"role": "user", "content": user_parts},
        ],
        temperature=temp,
    )

    content = response.choices[0].message.content or ""

    try:
        jobs_raw, manim_code = extract_jobs_and_code(content)
    except Exception as exc:
        placeholder = _placeholder_output(problem_dir_path, f"LLM output parsing failed: {exc}")
        return placeholder.as_dict()

    code_path.write_text(content, encoding="utf-8")
    manim_path.write_text(manim_code, encoding="utf-8")
    jobs_path.write_text(json.dumps(jobs_raw, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")

    return CodegenResult(code_path, manim_path, jobs_path, jobs_raw, manim_code, "generated").as_dict()


def _gather_image_parts(paths: Iterable[Path]) -> List[Dict[str, Any]]:
    """이미지들을 OpenAI API 형식으로 변환"""
    parts: List[Dict[str, Any]] = []
    for candidate in paths:
        encoded = _encode_image(candidate)
        if encoded:
            parts.append(encoded)
    return parts